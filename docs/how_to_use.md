---
layout: default
title: How to use
nav_order: 4
---

# How to Use

This section introduces three fitting algorithms: `AGCGA`, proposed in [1](https://link.springer.com/article/10.1007/s10851-014-0495-2), `AACGA`, proposed in [2](https://link.springer.com/book/10.1007/978-3-642-31794-1), and our proposed algorithm, `ICGA`. In addition, we present a joint fitting and classification algorithm, `fittingclass`, and a detection algorithm, `LOVO-CGA`.

## Using Artificially Generated Problems

If you generated a dataset using the `build_problem` function, you can load and use it in the following way.

Consider, for example, the file `sphere2D_-2.0_3.0_9.0_15.0_2.csv`, generated by `build_problem`. To load this problem into your workspace, use:

```julia
julia> prob = load_problem("sphere2D_-2.0_3.0_9.0_15.0_2.csv")
```

After loading, you can access the key components of the problem with:

- `prob.data`: the matrix of input points;
- `prob.npts`: the total number of points;
- `prob.nout`: the number of outliers.

For fitting problems, you can use `prob.data` as the point matrix; for classification and detection tasks, you can also use `prob.nout` to specify the number of outliers.


## Fitting

To use any of the fitting algorithms, provide a matrix where each row represents a point in Euclidean space, and specify the target object as a string. Supported objects include: `"sphere"`, `"plane"`, `"circle"`, and `"line"`.

### Syntax

```julia
ICGA(data::Matrix, object::String)
```

### Example

Consider a matrix `D` representing a set of points sampled from a sphere. To fit the sphere:

```julia
julia> ICGA(D, "sphere")
```

## Fitting and Classification

The `fittingclass` algorithm performs both fitting and classification. It takes a matrix of points corresponding to the object set \( Q = \{\text{spheres}, \text{hyperplanes}, \text{circles}, \text{lines}\} \), and two threshold values, `ε₁` and `ε₂`. For Gaussian noise, good performance has been observed with `ε₁ = 1.0` and `ε₂ = 1.0e-2`.

### Syntax

```julia
fittingclass(data::Matrix, ε₁::Float64, ε₂::Float64)
```

### Example

Given a matrix `D` containing a set of points:

```julia
julia> fittingclass(D, 1.0, 1.0e-2)
```

## Detection

To detect a specific object in the set \( Q = \{\text{spheres}, \text{hyperplanes}, \text{circles}, \text{lines}\} \), use the `LOVOCGA` function. The input parameters are:

- `data`: matrix of input points;
- `nout`: number of expected outliers;
- `θ`: initial guess vector;
- `method`: fitting method (`"AGCGA"`, `"AACGA"`, or `"ICGA"`);
- `object`: target object to detect.

### Syntax

```julia
LOVOCGA(data::Matrix, nout::Int, θ::Vector, method::String, object::String)
```

### Example

Let `D` be a matrix containing 20 points from a circle, with 4 of them being outliers. You can run the detection algorithm as follows:

```julia
julia> LOVOCGA(D, 4, [1.0, 1.0, 1.0, 1.0, 1.0], "AGCGA", "circle")
```

## Detection and Classification

To simultaneously detect and classify objects in the set \( Q = \{\text{spheres}, \text{hyperplanes}, \text{circles}, \text{lines}\} \), use the `LOVOCLASSIFICATION` function. Input parameters include:

- `data`: matrix of input points;
- `nout`: number of outliers;
- `θ`: initial guess vector of length `n+2`;
- `ε₁`, `ε₂`: threshold values for classification.

### Syntax

```julia
LOVOCLASSIFICATION(data::Matrix, nout::Int, θ::Vector, ε₁::Float64, ε₂::Float64)
```

### Example

Suppose `D` is a matrix of 40 points with 8 outliers sampled from one of the objects in \( Q \). The algorithm can be used as follows:

```julia
julia> LOVOCLASSIFICATION(D, 8, [1.0, 1.0, 1.0, 1.0, 1.0], 1.5, 1.0e-3)
```